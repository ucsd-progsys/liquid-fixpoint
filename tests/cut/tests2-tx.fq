
// This qualifier saves the day; solve constraints WITHOUT IT
// qualif Zog(v:a): (10 <= v)

// But you may use this one
qualif Pog(v:a): (0 <= v)


// Version 1 (eliminate k1)

constraint:
  env [ x: {v: int | v = 10}; 
        a: {v: int | k0 \/ (v=0) }]
  grd true
  lhs {v : int | v = x + a}
  rhs {v : int | k0}
  id 1 

constraint:
  env [y: {v: int | v = 20}; 
       b: {v: int | k0 \/ (v=0) }]
  grd true 
  lhs {v : int | v = y + b}
  rhs {v : int | k0}
  id 2 

constraint:
  env [c: {v: int | k0    }]
  grd true 
  lhs {v : int | v = c  }
  rhs {v : int | 10 <= v}
  id 4 

wf:
  env [ ]
  reft {v: int | k0}





// Version 2 (eliminate k0)

constraint:
  env [ ]
  grd true
  lhs {v : int | v = 0}
  rhs {v : int | k1 }
  id 0 

constraint:
  env [ ]
  grd true 
  lhs {v : int | (\exists x a. (x=10) /\ k1[a/v] /\ (v = x+a))
              /\ (\exists y b. (y=20) /\ k1[b/v] /\ (v = y+b)) }
  rhs {v : int | k1}
  id 3

constraint:
  env [c: {v: int | (\exists x a. (x=10) /\ k1[a/v] /\ (v = x+a))
                 /\ (\exists y b. (y=20) /\ k1[b/v] /\ (v = y+b)) }]
  grd true 
  lhs {v : int | v = c  }
  rhs {v : int | 10 <= v}
  id 4 

wf:
  env [ ]
  reft {v: int | k1}